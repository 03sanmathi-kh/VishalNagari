<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Akshata â€“ Traffic Portfolio</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body { margin:0; font-family:'Segoe UI',sans-serif; transition:background 0.3s,color 0.3s; min-height:100vh; overflow-x:hidden; }
body.dark{background:#0a0a0a;color:#fff;}
body.light{background:#f5f5f5;color:#000;}

.wave-bg{position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;overflow:hidden;}
.wave{position:absolute;width:200%;height:200%;opacity:0.5;animation:waveMove 30s linear infinite;}
.wave1{fill:#e74c3c;}
.wave2{fill:#f39c12;}
.wave3{fill:#c0392b;}
body.light .wave1{fill:#fab1a0;}
body.light .wave2{fill:#ffeaa7;}
body.light .wave3{fill:#ff7675;}

@keyframes waveMove{
 0%{transform:translateX(0) translateY(0) rotate(0deg);}
 50%{transform:translateX(10%) translateY(5%) rotate(2deg);}
 100%{transform:translateX(0) translateY(0) rotate(0deg);}
}

header{text-align:center;padding:40px 20px;}
header h1{font-size:42px;font-weight:900;color:#e74c3c;}
header h3{font-size:22px;font-weight:600;color:#3498db;}
header p{max-width:800px;margin:20px auto;font-size:16px;line-height:1.6;color:inherit;}

.hex-container{display:flex;flex-wrap:wrap;justify-content:center;gap:30px;padding:30px;}
.hex{
 position:relative;width:160px;height:90px;display:flex;
 align-items:center;justify-content:center;font-weight:600;
 text-align:center;cursor:pointer;transition:transform 0.3s ease;
 color:#fff;border-radius:12px;
}
.hex:hover{transform:scale(1.08);}
.flow{background:#e74c3c;}
.signal{background:#3498db;}
.accident{background:#f1c40f;}
.parking{background:#2ecc71;}
.emergency{background:#9b59b6;}
.evpriority{background:#1abc9c;}
.trie{background:#e84393;}
.infra{background:#2d3436;}
.roadquality{background:#d63031;}

.module-content{display:none;margin:20px auto;padding:20px;border-radius:15px;
 max-width:900px;background:rgba(255,255,255,0.05);}
.module-content h2{font-size:24px;margin-bottom:10px;}
.module-content h3{font-size:20px;margin-bottom:5px;}
.module-content p{font-size:16px;line-height:1.6;margin-bottom:10px;}
.module-content ul{margin-left:20px;}

.code-btn{
 background:#e67e22;border:none;padding:10px 20px;color:white;
 border-radius:8px;cursor:pointer;font-weight:600;margin-bottom:10px;
}
.code-btn:hover{background:#d35400;}

#themeBtn,#homeBtn{
 position:fixed;top:20px;padding:10px 20px;font-size:14px;cursor:pointer;
 border:none;border-radius:8px;color:#fff;transition:background 0.3s;
}
#themeBtn{right:20px;background:#e74c3c;}
#themeBtn:hover{background:#3498db;}
#homeBtn{left:20px;background:#2ecc71;}
#homeBtn:hover{background:#27ae60;}

/* Fullscreen Code Viewer */
#codeViewer{
  display:none;
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  background:rgba(0,0,0,0.95);
  color:white; padding:30px;
  overflow:auto;
  z-index:9999;
}

/* small responsive */
@media (max-width:600px){
  .hex{width:140px;height:80px;font-size:14px;}
  header h1{font-size:32px;}
}
</style>
</head>

<body class="dark">

<div class="wave-bg">
<svg class="wave wave1" viewBox="0 0 1440 320"><path d="M0,192 C480,320 960,64 1440,192 L1440,320 L0,320 Z"></path></svg>
<svg class="wave wave2" viewBox="0 0 1440 320"><path d="M0,256 C480,128 960,384 1440,256 L1440,320 L0,320 Z"></path></svg>
<svg class="wave wave3" viewBox="0 0 1440 320"><path d="M0,224 C480,96 960,352 1440,224 L1440,320 L0,320 Z"></path></svg>
</div>

<button id="homeBtn" onclick="goHome()">ğŸ  Home</button>
<button id="themeBtn" onclick="toggleTheme()">ğŸŒ™ Dark Mode</button>

<header>
<h1>Akshata</h1>
<h3>Traffic Management â€“ Vishalnagari</h3>
<p>Vishalnagari's Traffic domain ensures safe, fast, and intelligent mobility for every citizen.</p>
</header>

<div class="hex-container">
<div class="hex flow" onclick="toggleModule('a1')">Intelligent Traffic Density Management</div>
<div class="hex signal" onclick="toggleModule('a2')">Smart EV-Only Road Routing</div>
<div class="hex accident" onclick="toggleModule('a3')">Visitor Vehicle Bypass</div>
<div class="hex parking" onclick="toggleModule('a4')">Multi-Lane Road Separation</div>
<div class="hex roadquality" onclick="toggleModule('a5')">Road Quality Monitoring</div>
<div class="hex evpriority" onclick="toggleModule('a6')">Traffic Signal EV Priority</div>
<div class="hex trie" onclick="toggleModule('a7')">Smart Search System (Trie)</div>
<div class="hex infra" onclick="toggleModule('a8')">Urban Infrastructure Maintenance</div>
</div>

<!-- MODULES -->
<!-- MODULE 1 -->
<div id="a1" class="module-content">
<h2>Intelligent Traffic Density Management System</h2>

<h3>Problem</h3>
<p>The city faces uneven traffic distribution because vehicles crowd main roads while other routes stay empty. Manual traffic control fails during peak hours, leading to congestion, delays, and inefficient EV flow.</p>

<h3>Solution</h3>
<p>A real-time automated traffic density system that uses sensors, cameras, and algorithms to monitor road load, rank congestion levels, and automatically adjust signal timings.</p>

<h3>Data Structures Used</h3>
<ul>
<li>Array â†’ Store live sensor data (vehicle count, speed).</li>
<li>Max Heap â†’ Identify most congested road instantly.</li>
<li>Queue â†’ Manage vehicles approaching each signal.</li>
<li>Graph â†’ Represent entire road network for cross-road density checks.</li>
</ul>

<h3>Algorithms Used</h3>
<ul>
<li>Merge Sort â†’ Sort road densities for ranking.</li>
<li>Heap Operations â†’ Prioritize which road gets green signal first.</li>
<li>BFS â†’ Spread density updates across nearby intersections.</li>
</ul>

<h3>Step-by-Step Process</h3>
<p>1. Sensors send vehicle counts â†’ stored in array.</p>
<p>2. Merge Sort arranges roads from most to least crowded.</p>
<p>3. Max Heap picks the top 3 highest-density roads.</p>
<p>4. BFS sends density updates to all connected intersections (graph).</p>
<p>5. Heap-based prioritization assigns green time to the busiest lanes.</p>
<p>6. Signal controller updates timings in real time.</p>
<p>7. Dashboard shows congestion map to users.</p>

<hr>

<!-- ARRAY + MERGE SORT -->
<button class="code-btn" onclick="openCodeViewer('Array + Merge Sort â€“ Congestion Ranking', 
`#include &lt;iostream&gt;
using namespace std;

void merge(int a[], int l, int m, int r) {
    int n1 = m-l+1, n2=r-m;
    int L[n1], R[n2];
    for(int i=0;i&lt;n1;i++) L[i]=a[l+i];
    for(int i=0;i&lt;n2;i++) R[i]=a[m+1+i];
    int i=0,j=0,k=l;
    while(i&lt;n1 &amp;&amp; j&lt;n2){
        if(L[i]&gt;=R[j]) a[k++]=L[i++];
        else a[k++]=R[j++];
    }
    while(i&lt;n1) a[k++]=L[i++];
    while(j&lt;n2) a[k++]=R[j++];
}

void mergeSort(int a[], int l, int r){
    if(l&lt;r){
        int m=l+(r-l)/2;
        mergeSort(a,l,m);
        mergeSort(a,m+1,r);
        merge(a,l,m,r);
    }
}

int main(){
    int n; cin&gt;&gt;n;
    int arr[n];
    for(int i=0;i&lt;n;i++) cin&gt;&gt;arr[i];
    mergeSort(arr,0,n-1);
    for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i]&quot; &quot;;
    return 0;
}`)">ğŸ“Œ Array + Merge Sort</button>

<!-- MAX HEAP -->
<button class="code-btn" onclick="openCodeViewer('Max Heap â€“ Select Busiest Roads',
`#include &lt;iostream&gt;
using namespace std;

void heapify(int h[], int n, int i){
    int k=i,v=h[i]; bool heap=false;
    while(!heap &amp;&amp; 2*k+1&lt;n){
        int j=2*k+1;
        if(j+1&lt;n &amp;&amp; h[j]&lt;h[j+1]) j++;
        if(v&gt;=h[j]) heap=true;
        else{ h[k]=h[j]; k=j; }
    }
    h[k]=v;
}

void buildHeap(int h[], int n){
    for(int i=n/2;i&gt;=0;i--) heapify(h,n,i);
}

int main(){
    int n; cin&gt;&gt;n;
    int h[n];
    for(int i=0;i&lt;n;i++) cin&gt;&gt;h[i];
    buildHeap(h,n);
    for(int i=0;i&lt;n;i++) cout&lt;&lt;h[i]&quot; &quot;;
}`)">ğŸ“Œ Max Heap</button>

<!-- BFS -->
<button class="code-btn" onclick="openCodeViewer('BFS â€“ Spread Density Updates',
`#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

void BFS(int s, vector&lt;int&gt; adj[], int n){
    vector&lt;bool&gt; vis(n,false);
    queue&lt;int&gt; q;
    q.push(s); vis[s]=true;
    while(!q.empty()){
        int u=q.front(); q.pop();
        cout&lt;&lt;u&quot; &quot;;
        for(int v: adj[u])
            if(!vis[v]){ q.push(v); vis[v]=true; }
    }
}

int main(){
    int n,m; cin&gt;&gt;n&gt;&gt;m;
    vector&lt;int&gt; adj[n];
    for(int i=0;i&lt;m;i++){
        int u,v; cin&gt;&gt;u&gt;&gt;v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    BFS(0,adj,n);
}`)">ğŸ“Œ BFS</button>

</div>
<div id="a2" class="module-content">
<h2>Smart EV-Only Road Routing System</h2>

<h3>Problem</h3>
<p>EV traffic inside the city gets delayed due to congestion, and non-EV vehicles entering EV zones cause delays and pollution. Manual route management cannot ensure smooth flow for EVs.</p>

<h3>Solution</h3>
<p>A smart routing system that monitors EV traffic, calculates the fastest path using real-time data, and restricts non-EV vehicles automatically.</p>

<h3>Data Structures Used</h3>
<ul>
<li>Graph â†’ Represent EV road network.</li>
<li>Priority Queue (Heap) â†’ Select the next intersection with minimum travel time.</li>
</ul>

<h3>Algorithms Used</h3>
<ul>
<li>Dijkstraâ€™s Algorithm â†’ Calculate real-time shortest path for EVs.</li>
<li>BFS â†’ Check connected intersections for alternate routing in case of congestion.</li>
</ul>

<h3>Step-by-Step Process</h3>
<p>1. Map all EV roads as graph nodes and edges with travel time as weights.</p>
<p>2. Input current EV positions and destinations.</p>
<p>3. Use Dijkstra to find the shortest congested-free path.</p>
<p>4. BFS monitors connected intersections for traffic updates.</p>
<p>5. Navigation system directs EVs along optimal paths.</p>
<p>6. Non-EV vehicles are restricted using smart gates.</p>

<hr>

<!-- GRAPH REPRESENTATION -->
<button class="code-btn" onclick="openCodeViewer('Graph Representation',
`#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n,m;
    cin>>n>>m; 
    vector<pair<int,int>> g[n];
    for(int i=0;i<m;i++){
        int u,v,w; 
        cin>>u>>v>>w;
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }
    for(int i=0;i<n;i++){
        cout<<"Node "<<i<<": ";
        for(auto p:g[i]) cout<<"("<<p.first<<","<<p.second<<") ";
        cout<<endl;
    }
    return 0;
}`)">ğŸ“Œ Graph Representation</button>

<!-- DIJKSTRA -->
<button class="code-btn" onclick="openCodeViewer('Dijkstraâ€™s Algorithm',
`#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main(){
    int n,m; cin>>n>>m;
    vector<pair<int,int>> g[n];
    for(int i=0;i<m;i++){
        int u,v,w; cin>>u>>v>>w;
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }

    int src; cin>>src;
    vector<int> dist(n,1e9);
    dist[src]=0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0,src});
    while(!pq.empty()){
        auto [d,u]=pq.top(); pq.pop();
        for(auto [v,w]:g[u]){
            if(dist[v]>d+w){
                dist[v]=d+w;
                pq.push({dist[v],v});
            }
        }
    }
    for(int i=0;i<n;i++) cout<<"Distance to "<<i<<": "<<dist[i]<<endl;
    return 0;
}`)">ğŸ“Œ Dijkstraâ€™s Algorithm</button>

<!-- BFS INTERSECTION MONITORING -->
<button class="code-btn" onclick="openCodeViewer('BFS â€“ Monitor Connected Intersections',
`#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main(){
    int n,m; cin>>n>>m;
    vector<int> g[n];
    for(int i=0;i<m;i++){
        int u,v; cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    int start; cin>>start;
    vector<bool> vis(n,false);
    queue<int> q;
    q.push(start); vis[start]=true;
    while(!q.empty()){
        int u=q.front(); q.pop();
        cout<<u<<" ";
        for(int v:g[u]){
            if(!vis[v]){
                vis[v]=true;
                q.push(v);
            }
        }
    }
    return 0;
}`)">ğŸ“Œ BFS Monitoring</button>

</div>
<div id="a3" class="module-content">
<h2>Visitor Vehicle Bypass Routing & Control System</h2>

<h3>Problem</h3>
<p>Visitors entering the smart EV city with petrol/diesel vehicles accidentally enter EV-only zones. This creates:</p>
<ul>
<li>traffic jams</li>
<li>enforcement issues</li>
<li>delays for local EV users</li>
<li>confusion for outsiders</li>
</ul>
<p>The city needs a system that automatically detects visitor vehicles and guides them through a dedicated bypass road without disturbing internal EV traffic.</p>

<h3>Solution</h3>
<p>A smart control system that:</p>
<ul>
<li>Detects visitor vehicles at city entry</li>
<li>Classifies them as EV / Non-EV</li>
<li>Automatically routes outsiders through a bypass-only path</li>
<li>Prevents entry into EV roads using smart gates</li>
<li>Provides fastest bypass using graph shortest paths</li>
</ul>

<h3>Data Structures Used</h3>
<ul>
<li>Graph â†’ represent city roads + bypass roads</li>
<li>Queue â†’ manage incoming vehicles at checkpoints</li>
<li>Hash Table â†’ store vehicle type (EV / Non-EV)</li>
<li>Priority Queue (Min Heap) â†’ find fastest bypass route (used by Dijkstra)</li>
</ul>

<h3>Algorithms Used</h3>
<ul>
<li>Dijkstraâ€™s Algorithm â†’ compute fastest bypass for visitors</li>
<li>BFS (optional) â†’ check if any entry point is blocked</li>
<li>Hashing â†’ quickly identify visitor vs resident vehicle</li>
</ul>

<h3>Step-by-Step Process</h3>
<p>1. Vehicle arrives at entry gate â†’ number plate read.</p>
<p>2. Hash table lookup identifies:</p>
<ul>
<li>EV â†’ allowed inside city</li>
<li>Non-EV â†’ redirect to bypass</li>
</ul>
<p>3. If Non-EV:</p>
<ul>
<li>Dijkstra calculates shortest bypass route</li>
<li>Vehicle is sent only on non-interfering path</li>
<li>Queue manages vehicles waiting at gate.</li>
<li>If one bypass segment is blocked â†’ BFS quickly finds next reachable bypass path.</li>
<li>Gate opens + navigation is shown to visitor.</li>
</ul>

<hr>

<!-- HASH TABLE -->
<button class="code-btn" onclick="openCodeViewer('Hash Table â€“ Identify Visitor Vehicle',
`#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string,string> type;
    type["KA01AB1234"] = "EV";
    type["MH09XY7777"] = "NON-EV";

    string plate;  
    cin >> plate;

    if(type[plate] == "NON-EV") 
        cout << "Use BYPASS\\n";
    else
        cout << "Welcome to EV City\\n";
}`)">ğŸ“Œ Hash Table</button>

<!-- QUEUE -->
<button class="code-btn" onclick="openCodeViewer('Queue â€“ Vehicles Waiting at Gate',
`#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<string> q;
    q.push("CAR1");
    q.push("CAR2");
    q.push("CAR3");

    while(!q.empty()) {
        cout << "Processing " << q.front() << endl;
        q.pop();
    }
}`)">ğŸ“Œ Queue</button>

<!-- DIJKSTRA -->
<button class="code-btn" onclick="openCodeViewer('Dijkstra â€“ Fastest Bypass Route',
`#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    int n = 4;
    vector<pair<int,int>> g[5];
    g[1]={{2,4},{3,2}};
    g[2]={{4,5}};
    g[3]={{4,1}};

    vector<int> d(n+1,1e9);
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;

    d[1]=0; pq.push({0,1});
    while(!pq.empty()){
        auto [w,u]=pq.top(); pq.pop();
        for(auto [v,c]:g[u])
            if(d[v] > w+c){
                d[v]=w+c;
                pq.push({d[v],v});
            }
    }
    cout << "Fastest bypass to node 4 = " << d[4];
}`)">ğŸ“Œ Dijkstra</button>

<!-- BFS -->
<button class="code-btn" onclick="openCodeViewer('BFS â€“ Next Available Bypass',
`#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    vector<int> g[5]={{},{2,3},{4},{4},{}};
    bool vis[5]={0};
    queue<int> q;
    q.push(1); vis[1]=1;

    while(!q.empty()){
        int u=q.front(); q.pop();
        cout<<u<<" ";
        for(int v:g[u])
            if(!vis[v]){
                vis[v]=1;
                q.push(v);
            }
    }
}`)">ğŸ“Œ BFS</button>

</div>

<!-- MODULE 4 & 5 & Remaining (you provided earlier, preserved) -->
<div id="a4" class="module-content">
<h2>Multi-Lane Road Separation + Smart Gate Control System</h2>

<h3>Problem</h3>
<p>All types of vehicles move on the same road â†’ EVs, petrol/diesel vehicles, buses, scooters, trucks. This causes congestion, delays, and unnecessary traffic mixing.</p>
<p>The city needs separate lanes for:</p>
<ul>
<li>EV buses</li>
<li>EV cars</li>
<li>EV scooters</li>
<li>Petrol/Diesel vehicles (resident vehicles)</li>
<li>Outsider vehicles</li>
<li>Goods trucks</li>
</ul>
<p>Also, the lanes must be monitored so that vehicles enter only their allowed lane.</p>

<h3>Solution</h3>
<p>A smart multi-lane road system where each lane is mapped, classified, and monitored using sensors and gates. When a vehicle arrives at a lane gate â†’ the system checks its type and opens/blocks the gate automatically.</p>

<h3>Data Structures Used</h3>
<ul>
<li>Graph â†’ Represent all lanes and their connectivity.</li>
<li>Hash Table â†’ Map vehicle number â†’ vehicle type (EV, petrol, diesel, truck).</li>
<li>Queue â†’ Store vehicles waiting at lane gates.</li>
</ul>

<h3>Algorithms Used</h3>
<ul>
<li>BFS â†’ Check which lane path is available for a vehicle type.</li>
<li>Hash Lookup â†’ Fast classification of vehicle type.</li>
<li>Simple Sorting (Selection Sort) â†’ Sort lanes by load (optional).</li>
</ul>

<h3>Step-by-Step Process</h3>
<ol>
<li>Vehicle arrives at lane entrance.</li>
<li>ANPR camera reads vehicle number.</li>
<li>Vehicle number is searched in hash table â†’ find vehicle type.</li>
<li>Based on type:
    <ul>
    <li>EV Car â†’ EV-Car Lane</li>
    <li>EV Bus â†’ EV-Bus Lane</li>
    <li>EV Scooter â†’ EV-Scooter Lane</li>
    <li>Petrol/Diesel (Resident) â†’ Non-EV Lane</li>
    <li>Outsider Vehicle â†’ Visitor Lane</li>
    <li>Truck â†’ Goods Lane</li>
    </ul>
</li>
<li>BFS checks if lane path is free or congested.</li>
<li>If lane free â†’ gate opens.</li>
<li>If lane full â†’ vehicle is added to a queue until lane clears.</li>
<li>Lanes are monitored and updated in real time.</li>
</ol>

<hr>

<!-- HASH TABLE -->
<button class="code-btn" onclick="openCodeViewer('Hash Table â€“ Vehicle Type Lookup',
`#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, string> vehicleType;

    vehicleType["KA01EV1234"] = "EV-Car";
    vehicleType["KA09AB7890"] = "Petrol";
    vehicleType["KA55TR1122"] = "Truck";

    string num;
    cin >> num;

    if(vehicleType.count(num))
        cout << vehicleType[num];
    else
        cout << "Unknown Vehicle";

    return 0;
}`)">ğŸ“Œ Hash Table</button>

<!-- QUEUE -->
<button class="code-btn" onclick="openCodeViewer('Queue â€“ Vehicles Waiting at a Lane',
`#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<string> q;
    q.push("KA01EV1234");
    q.push("KA09AB7890");
    q.push("KA55TR1122");

    while(!q.empty()) {
        cout << q.front() << " enters lane\\n";
        q.pop();
    }
    return 0;
}`)">ğŸ“Œ Queue</button>

<!-- BFS -->
<button class="code-btn" onclick="openCodeViewer('BFS â€“ Check Lane Path',
`#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    int n = 5;
    vector<vector<int>> g = {
        {1},        // 0 â†’ EV-Car Lane
        {2},        // 1 â†’ EV-Bus Lane
        {3},        // 2 â†’ Goods Lane
        {},         // 3 â†’ End
        {1,2,0}     // 4 â†’ Main Junction
    };

    int start = 4;      // Junction
    int target = 2;     // Goods Lane

    queue<int> q;
    vector<bool> vis(n, false);

    q.push(start);
    vis[start] = true;

    bool ok = false;

    while(!q.empty()) {
        int u = q.front(); q.pop();
        if(u == target) { ok = true; break; }
        for(int v : g[u])
            if(!vis[v]) { vis[v] = true; q.push(v); }
    }

    if(ok) cout << "Lane reachable";
    else cout << "Lane blocked";

    return 0;
}`)">ğŸ“Œ BFS</button>

<!-- SELECTION SORT -->
<button class="code-btn" onclick="openCodeViewer('Selection Sort â€“ Optional Lane Load Sorting',
`#include <iostream>
using namespace std;

int main() {
    int a[5] = {30, 10, 50, 20, 40};

    for(int i=0;i<5;i++){
        int min = i;
        for(int j=i+1;j<5;j++)
            if(a[j] < a[min]) min = j;
        swap(a[i], a[min]);
    }

    for(int x : a) cout << x << " ";
    return 0;
}`)">ğŸ“Œ Selection Sort</button>

</div>
<div id="a5" class="module-content">
<h2>Road Quality Monitoring & Smart Construction Analytics System</h2>

<h3>Problem</h3>
<p>The city faces continuous road damage due to heavy EV/bus usage, monsoon conditions, and poor maintenance scheduling. Repairs happen late, causing potholes, breakdowns, and traffic jams. No system exists to monitor damage in real time or prioritize which roads should be repaired first.</p>

<h3>Solution</h3>
<p>A smart automated system that:</p>
<ul>
<li>Detects road cracks, bumps, and potholes using sensors/cameras</li>
<li>Tracks road health across all lanes (EV lane, petrol lane, goods lane)</li>
<li>Prioritizes repair based on severity, traffic load, and safety</li>
<li>Helps the city plan road construction scientifically instead of randomly</li>
</ul>

<h3>Data Structures Used</h3>
<ul>
<li>Graph â†’ Represent city road network</li>
<li>Min-Heap â†’ Pick highest-priority road repairs</li>
<li>Hash Table â†’ Store damage reports from sensors/complaints</li>
<li>BST â†’ Sort roads by severity index</li>
</ul>

<h3>Algorithms Used</h3>
<ul>
<li>DFS â†’ Detect clusters of connected damaged road segments</li>
<li>BFS â†’ Find shortest path to nearest repair team</li>
<li>Merge Sort â†’ Sort repair sites by cost or severity</li>
<li>Prim's/Kruskalâ€™s (Optional) â†’ Plan cost-efficient new road layouts</li>
</ul>

<h3>Step-by-Step Process</h3>
<ol>
<li>Sensors & Mobile App Reports â†’ Hash Table: store severity, location, lane type, time of damage report.</li>
<li>Severity Index â†’ Insert into BST: roads sorted by damage level.</li>
<li>Min-Heap â†’ Pick Top Priority Repairs: automatically selects most urgent road segments.</li>
<li>DFS â†’ Cluster Detection: if potholes appear in connected segments, treat as one repair project.</li>
<li>BFS â†’ Assign Repair Team: find nearest available repair vehicle/crew.</li>
<li>Merge Sort â†’ Cost Ranking: sort repair tasks by estimated cost/time.</li>
<li>Team Executes Work: status updated and displayed on the dashboard.</li>
</ol>

<hr>

<!-- HASH TABLE -->
<button class="code-btn" onclick="openCodeViewer('Hash Table â€“ Store Damage Reports',
`#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> damage;
    damage["RoadA"] = 4;  // severity
    damage["RoadB"] = 2;

    for(auto &x : damage)
        cout << x.first << " = " << x.second << endl;
}`)">ğŸ“Œ Hash Table</button>

<!-- MIN HEAP -->
<button class="code-btn" onclick="openCodeViewer('Min-Heap â€“ Pick Highest Priority Damage',
`#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<pair<int,string>> pq; // severity, road
    pq.push({5,"Lane1"});
    pq.push({2,"Lane2"});
    pq.push({8,"Lane3"});

    cout << "Most severe: " << pq.top().second << endl;
}`)">ğŸ“Œ Min-Heap</button>

<!-- DFS -->
<button class="code-btn" onclick="openCodeViewer('DFS â€“ Find Connected Damaged Segments',
`#include <iostream>
using namespace std;

void dfs(int g[5][5], int v, bool vis[]) {
    vis[v] = true;
    for(int i=0;i<5;i++)
        if(g[v][i] && !vis[i])
            dfs(g, i, vis);
}

int main() {
    int g[5][5] = {
        {0,1,0,0,0},
        {1,0,1,0,0},
        {0,1,0,1,0},
        {0,0,1,0,0},
        {0,0,0,0,0}
    };
    bool vis[5]={0};
    dfs(g,0,vis);
}`)">ğŸ“Œ DFS</button>

<!-- BFS -->
<button class="code-btn" onclick="openCodeViewer('BFS â€“ Find Nearest Repair Team',
`#include <iostream>
#include <queue>
using namespace std;

int main() {
    int g[5][5] = {
        {0,1,1,0,0},
        {1,0,0,1,0},
        {1,0,0,0,1},
        {0,1,0,0,0},
        {0,0,1,0,0}
    };

    queue<int> q;
    bool vis[5]={0};

    q.push(0);
    vis[0]=1;

    while(!q.empty()) {
        int x=q.front(); q.pop();
        cout<<x<<" ";

        for(int i=0;i<5;i++)
            if(g[x][i] && !vis[i]) {
                vis[i]=1;
                q.push(i);
            }
    }
}`)">ğŸ“Œ BFS</button>

</div>
<div id="a6" class="module-content"><h2>Module 6 â€“ Traffic Signal Optimization Using EV Priority</h2><p>Content + C++ codesâ€¦</p></div>
<div id="a7" class="module-content"><h2>Module 7 â€“ Smart City Search (Trie-Based)</h2><p>Content + C++ codesâ€¦</p></div>
<div id="a8" class="module-content"><h2>Module 8 â€“ Urban Infrastructure Maintenance & Planning</h2><p>Content + C++ codesâ€¦</p></div>

<!-- FULLSCREEN CODE VIEWER -->
<div id="codeViewer">
  <button onclick="closeCodeViewer()" style="
    position:fixed; right:30px; top:20px; background:#e74c3c;
    padding:10px 20px; border:none; border-radius:8px; color:white;
    font-size:16px; cursor:pointer;">
    âœ– Close
  </button>

  <h2 id="codeTitle" style="color:#f39c12;"></h2>
  <pre id="codeContent" style="white-space:pre-wrap; font-size:15px;"></pre>
</div>

<script>
// ---------------------------
// OPEN / CLOSE MODULE SECTIONS
// ---------------------------
function toggleModule(id){
    let target = document.getElementById(id);

    // close others
    document.querySelectorAll(".module-content").forEach(m=>{
        if(m.id !== id) m.style.display = "none";
    });

    // toggle selected
    target.style.display = (target.style.display === "block") ? "none" : "block";
}

// ---------------------------
// CODE VIEWER FUNCTIONALITY
// ---------------------------
function openCodeViewer(title, code){
    const viewer = document.getElementById("codeViewer");

    viewer.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;">
            <h2 style="margin:0;color:#f39c12;">${title}</h2>
        </div>

        <pre style="
            white-space: pre-wrap;
            padding: 15px;
            border-radius: 10px;
            font-size: 15px;
            overflow-x: auto;
            background: #111;
            box-shadow: 0 0 20px rgba(0,255,255,0.06);
            margin-top:12px;
        ">${code}</pre>

        <button onclick="closeCodeViewer()" style="
            padding: 10px 20px;
            background: #e74c3c;
            border: none;
            color: white;
            font-size: 16px;
            margin-top: 10px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 14px rgba(231,76,60,0.3);
        ">Close</button>
    `;

    viewer.style.display = "block";
}

function closeCodeViewer(){
    document.getElementById("codeViewer").style.display = "none";
}

// ---------------------------
// THEME TOGGLE
// ---------------------------
function toggleTheme(){
    const body = document.body;

    if(body.classList.contains("light")){
        body.classList.remove("light");
        body.classList.add("dark");
        document.getElementById("themeBtn").innerHTML = "ğŸŒ™ Dark Mode";
    } else {
        body.classList.remove("dark");
        body.classList.add("light");
        document.getElementById("themeBtn").innerHTML = "â˜€ Light Mode";
    }
}

// ---------------------------
// GO HOME (collapse modules)
// ---------------------------
function goHome(){
    document.querySelectorAll(".module-content").forEach(m=>{
        m.style.display = "none";
    });
    window.scrollTo({top: 0, behavior: "smooth"});
}
</script>

</body>
</html>
